\part{动态规划}

\section{爬楼梯}

\textbf{题目描述：}
假设你正在爬楼梯。需要 n 阶你才能到达楼顶。

每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？

\textbf{解法一：}

\begin{lstlisting}
const climbStairs2 = (n) => {
    if (n <= 2) {
        return n;
    }
    
    let dp = new Array(n + 1);
    dp[1] = 1;
    dp[2] = 2;
    
    for (let i = 3; i <= n; i++) {
        dp[i] = dp[i - 1] + dp[i - 2];
    }
    
    return dp[n];
};
\end{lstlisting}

\textbf{解法二：}

\begin{lstlisting}
const climbStairs = (n) => {
    let firstStage = 1, secondStage = 2, latestStage

    if (n < 3) {
        return n;
    }
    for (let i = 3; i <= n; i++) {
        latestStage = firstStage + secondStage;
        firstStage = secondStage;
        secondStage = latestStage;
    }
    return latestStage;
};
\end{lstlisting}

\section{杨辉三角}

\textbf{题目描述：}

给定一个非负整数 numRows，生成「杨辉三角」的前 numRows 行。

在「杨辉三角」中，每个数是它左上方和右上方的数的和。

\textbf{解法一：}

\begin{lstlisting}
const generate = (numRows) => {
    const result = [];

    for (let i = 0; i < numRows; i++) {
        const row = new Array(i + 1).fill(1);
        for (let j = 1; j < i; j++) {
            row[j] = result[i - 1][j - 1] + result[i - 1][j];
        }
        result.push(row);
    }
    return result;
}
\end{lstlisting}

\textbf{解法二：}

\begin{lstlisting}
const generate = (numRows) => {
    if (numRows === 0) {
        return [];
    }
    const triangle = [];
    
    for (let i = 0; i < numRows; i++) {
        const row = new Array(i + 1);
        row[0] = 1;
        row[i] = 1;
        
        for (let j = 1; j < i; j++) {
            row[j] = triangle[i - 1][j - 1] + triangle[i - 1][j];
        }
        
        triangle.push(row);
    }
    
    return triangle;
}
\end{lstlisting}

\section{打家劫舍}
\textbf{题目描述：}

你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。

给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。

\textbf{解法一：}

\begin{lstlisting}
const rob = (nums) => {
    const dp = new Array(nums.length).fill(0);
    dp[0] = nums[0];
    if (nums.length >= 2) {
        dp[1] = Math.max(nums[0], nums[1]);
    }

    for (let i = 2; i < nums.length; i++) {
        dp[i] = Math.max(dp[i-2] + nums[i], dp[i-1]);
    }

    return dp[nums.length -1];
};
\end{lstlisting}

\textbf{解法二：}

\begin{lstlisting}
const rob = (nums) => {
    let prev = 0;    // dp[i-2]
    let curr = 0;    // dp[i-1]
    
    for (let num of nums) {
        const temp = curr;
        curr = Math.max(curr, prev + num);
        prev = temp;
    }
    
    return curr;
};
\end{lstlisting}

\section{完全平方数}

\textbf{题目描述：}

给你一个整数 n ，返回 和为 n 的完全平方数的最少数量 。

完全平方数 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，1、4、9 和 16 都是完全平方数，而 3 和 11 不是。

\textbf{解法一：}

\begin{lstlisting}
    const numSquares = (n) => {
        const dp = new Array(n + 1).fill(0);
         
        for (let i = 1; i <= n; i++) {
            let min = Infinity;
            for (let j = 1; j*j <=i; j++) {
                min = Math.min(min, dp[i - j*j]);
            }
    
            dp[i] = min + 1;
        }
        
        return dp[n];
    };
\end{lstlisting}

\textbf{解法二：}

\begin{lstlisting}
const numSquares = (n) => {
    const dp = new Array(n + 1).fill(Infinity);
    dp[0] = 0;
    
    for (let i = 1; i <= n; i++) {
        for (let j = 1; j*j <= i; j++) {
            dp[i] = Math.min(dp[i], dp[i - j*j] + 1);
        }
    }
    
    return dp[n];
};
\end{lstlisting}


\section{零钱兑换}

\textbf{题目描述：}

给你一个整数数组 coins ，表示不同面额的硬币；以及一个整数 amount ，表示总金额。

计算并返回可以凑成总金额所需的 最少的硬币个数 。如果没有任何一种硬币组合能组成总金额，返回 -1 。

你可以认为每种硬币的数量是无限的。

\textbf{解法一：}

\begin{lstlisting}
    const coinChange = (coins, amount) => {
        const dp = new Array(amount + 1).fill(amount + 1);
        dp[0] = 0;
        
        for (let i = 1; i <= amount; i++) {
            for (const coin of coins) {
                if (coin <= i) {
                    dp[i] = Math.min(dp[i], dp[i - coin] + 1);
                }
            }
        }
        
        return dp[amount] > amount ? -1 : dp[amount];   
    };
\end{lstlisting}

\textbf{解法二：}

\begin{lstlisting}
    const coinChange2 = (coins, amount) => {
        if (!amount) {
            return 0;
        }
        let dp = new Array(amount + 1).fill(Infinity);
        dp[0] = 0;
        for (let i = 0; i < coins.length; i++) {
            for (let j = coins[i]; j <= amount; j++) {
                dp[j] = Math.min(dp[j - coins[i]] + 1, dp[j]);
            }
        }
        return dp[amount] === Infinity ? -1 : dp[amount];
    };
\end{lstlisting}

\section{单词拆分}
\textbf{题目描述：}

给你一个字符串 s 和一个字符串列表 wordDict 作为字典。如果可以利用字典中出现的一个或多个单词拼接出 s 则返回 true。

注意：不要求字典中出现的单词全部都使用，并且字典中的单词可以重复使用。

\textbf{解法一：}

\begin{lstlisting}
    const wordBreak = (s, wordDict) => {
        const dictSet = new Set(wordDict);
        const dp = new Array(s.length + 1).fill(false);
        dp[0] = true;
    
        for (let i = 1; i <= s.length; i++) {
            for (let j = 0; j < i; j++) {
                if (dp[j] && dictSet.has(s.slice(j, i))) {
                    dp[i] = true;
                    break;
                }
            }
        }
        
        return dp[s.length];
    };
\end{lstlisting}

\section{最长递增子序列}
\textbf{题目描述：}

给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。

子序列 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。

\textbf{解法一：}

\begin{lstlisting}
    const lengthOfLIS = (nums) => {
        const n = nums.length;
        let result = 1;
        const dp = new Array(n).fill(1);

        for (let i = 1; i < n; i++) {
            for (let j = 0; j < i; j++) {
                if (nums[i] > nums[j]) {
                    dp[i] = Math.max(dp[i], dp[j] + 1);
                }
            }
            result = Math.max(dp[i], result);
        }
        
        return result
    };
\end{lstlisting}

\section{乘积最大子数组}
\textbf{题目描述：}

给你一个整数数组 nums ，请你找出数组中乘积最大的非空连续 子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。

测试用例的答案是一个 32-位 整数。

请注意，一个只包含一个元素的数组的乘积是这个元素的值。

\textbf{解法一：}

\begin{lstlisting}
    const maxProduct = (nums) => {
        let maxSofar = nums[0], minSofar = nums[0], result = nums[0];

        for (let i = 1; i < nums.length; i++) {
            let temp = maxSofar;
            maxSofar = Math.max(nums[i], maxSofar * nums[i], minSofar * nums[i]);
            minSofar = Math.min(nums[i], temp * nums[i], minSofar * nums[i]);

            result = Math.max(maxSofar, result);
        }

        return result;
    };
\end{lstlisting}

\section{分割等和子集}
\textbf{题目描述：}

给你一个 只包含正整数 的 非空 数组 nums 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。

\textbf{解法一：}

\begin{lstlisting}
    const canPartition = (nums) => {
        let sum = 0, maxNum = 0;
        
        for (let num of nums) {
            sum += num;
            maxNum = Math.max(maxNum, num);
        }
        const targetVal = sum / 2;
        if (sum % 2 !== 0 || maxNum > targetVal) {
            return false;
        }
        
        const dp = new Array(targetVal + 1).fill(false);
        dp[0] = true;
    
        for (let i = 0; i < nums.length; i++) {
            for (let j = targetVal; j >= nums[i]; j--) {
                if (dp[j - nums[i]]) {
                    dp[j] = true;
                }
            }
            if (dp[targetVal]) {
                return true;
            }
        }
    
        return dp[targetVal]
    };
\end{lstlisting}

\section{最长有效括号}

\textbf{题目描述：}

给你一个只包含 '(' 和 ')' 的字符串，找出最长有效（格式正确且连续）括号 子串 的长度。

左右括号匹配，即每个左括号都有对应的右括号将其闭合的字符串是格式正确的，比如 "(()())"。

\textbf{解法一：}

\begin{lstlisting}
    const longestValidParentheses = (s) => {
        const stack = [-1];
        let maxLength = 0;

        for (let i = 0; i < s.length; i++) {
            if (s[i]==='(') {
                stack.push(i)
            } else {
                if (stack.length) {
                    maxLength = Math.max(maxLength, i - stack[stack.length-1]);
                } else {
                    stack.push(i);
                }
            }
        }

        return maxLength;
    };
\end{lstlisting}

\textbf{解法二：}

\begin{lstlisting}
    const longestValidParentheses2  = (s) => {
        const dp = new Array(s.length).fill(0);
        let  max  = 0;
        for (let i = 1; i < s.length; i++) {
            if(s[i] === ')') {
                if (s[i - 1] === '(') {
                    dp[i] = (i >= 2 ? dp[i-2] : 0) + 2;
                } else if (i - dp[i - 1] > 0 && s[i - dp[i - 1] -1] === '('){
                    dp[i] = dp[i-1] + 2 + (i - dp[i-1] >= 2 ? dp[i - dp[i-1] - 2] : 0)
                }
                max = Math.max(max, dp[i])
            }
        }

        return max
    }
\end{lstlisting}

\section{不同路径}

\textbf{题目描述：}

一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。

机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。

问总共有多少条不同的路径？

\textbf{解法一：}

\begin{lstlisting}
    const uniquePaths = (m, n) => {
        const dp = new Array(m).fill(0).map(() => new Array(n).fill(1));

        for (let i = 1; i < m; i++) {
            for (let j = 1; j < n; j++) {
                dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
            }
        }
        return dp[m-1][n-1]
    };
\end{lstlisting}

\section{最小路径和}

\textbf{题目描述：}
给定一个包含非负整数的 m x n 网格 grid ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。

说明：每次只能向下或者向右移动一步。

\textbf{解法一：}

\begin{lstlisting}
    const minPathSum = (grid) => {
        const m = grid.length;
        const n = grid[0].length;

        const dp = new Array(m).fill(0).map(() => new Array(n).fill(0));
        dp[0][0] = grid[0][0];

        for (let i = 1; i < m; i++) {
            dp[i][0] = dp[i - 1][0] + grid[i][0];
        }

        for (let j = 1; j < n; j++) {
            dp[0][j] = dp[0][j - 1] + grid[0][j];
        }

        for (let i = 1; i < m; i++) {
            for (let j = 1; j < n; j++) {
                dp[i][j] = Math.min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j];
            }
        }

        return dp[m - 1][n - 1];
    };
\end{lstlisting}


\section{最长回文子串}

\textbf{题目描述：}

给你一个字符串 s，找到 s 中最长的 回文 子串。

\textbf{解法一：}

\begin{lstlisting}
    const longestPalindrome = (s) => {
        const expandAroundCenter = (str, left, right) => {
            while (left >=0 && right < str.length && str[left] === str[right]) {
                left--;
                right++;
            }

            return right - left - 1;
        }

        let startIndex = 0; endIndex = 0;
        for (let i = 0; i < s.length; i++) {
            let length1 = expandAroundCenter(s, i, i);
            let length2 = expandAroundCenter(s, i, i + 1);
            let length = Math.max(length1, length2);

            if (length > endIndex - startIndex) {
                startIndex = i - Math.floor((length -1) / 2);
                endIndex = i + Math.floor(length/2);
            }
        }

        return s.slice(startIndex, endIndex + 1);
    };
\end{lstlisting}

\textbf{解法二：}

\begin{lstlisting}
    const longestPalindromeDP = (s) => {
        const n = s.length;
        if (n < 2) {
            return s;
        }
        
        const dp = new Array(n).fill(false).map(() => new Array(n).fill(false));
        let maxLength = 1;
        let start = 0;
        
        for (let i = 0; i < n; i++) {
            dp[i][i] = true;
        }
        
        for (let length = 2; length <= n; length++) {
            for (let i = 0; i <= n - length; i++) {
                const j = i + length - 1;
                
                if (s[i] === s[j]) {
                    if (length === 2 || dp[i + 1][j - 1]) {
                        dp[i][j] = true;
                        
                        if (length > maxLength) {
                            start = i;
                            maxLength = length;
                        }
                    }
                }
            }
        }
        
        return s.substring(start, start + maxLength);
    }
\end{lstlisting}    

\textbf{解法三：}

\begin{lstlisting}
    const longestPalindromeDP2 = (s) => {
        if (s.length === 0) {
            return "";
        }
        
        let start = 0, end = 0;
        const dp = new Array(s.length);
        
        for (let i = 0; i < s.length; i++) {
            for (let j = 0; j <= i; j++) {
                if (i === j) {
                    dp[j] = true;
                } else if (j + 1 === i) {
                    dp[j] = s[j] === s[i];
                } else {
                    dp[j] = s[j] === s[i] && dp[j + 1];
                }
                
                if (dp[j] && i - j > end - start) {
                    start = j;
                    end = i;
                }
            }
        }
        
        return s.substring(start, end + 1);
    };
\end{lstlisting}

\section{最长公共子序列}

\textbf{题目描述：}

给定两个字符串 text1 和 text2，返回这两个字符串的最长 公共子序列 的长度。如果不存在 公共子序列 ，返回 0 。

一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。

例如，"ace" 是 "abcde" 的子序列，但 "aec" 不是 "abcde" 的子序列。
两个字符串的 公共子序列 是这两个字符串所共同拥有的子序列。

\textbf{解法一：}

\begin{lstlisting}
    const longestCommonSubsequence = (text1, text2) => {
        const m = text1.length;
        const n = text2.length;
        const dp = new Array(m + 1).fill(0).map(() => new Array(n + 1).fill(0));

        for (let i = 1; i <= m; i++) {
            for (let j = 1; j <= n; j++) {
                if (text1[i - 1] === text2[j - 1]) {
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                } else {
                    dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
                }
            }
        }

        return dp[m][n]
    };
\end{lstlisting}

\section{编辑距离}

\textbf{题目描述：}

给你两个单词 word1 和 word2， 请返回将 word1 转换成 word2 所使用的最少操作数  。

你可以对一个单词进行如下三种操作：

插入一个字符
删除一个字符
替换一个字符

\textbf{解法一：}

\begin{lstlisting}
    const minDistance = (word1, word2) => {
        const m = word1.length;
        const n = word2.length;
        const dp = new Array(m+1).fill(0).map(() => new Array(n+1).fill(0));
        for (let i = 0; i <= m; i++) {
            dp[i][0] = i;
        }
        for (let j = 0; j <= n; j++) {
            dp[0][j] = j;
        }

        for (let i = 1; i <= m; i++) {
            for (let j = 1; j <= n; j++) {
                if (word1[i - 1]  === word2[j - 1]) {
                    dp[i][j] = dp[i-1][j-1];
                } else {
                    // dp[i - 1][j] + 1 delete word1[i - 1],  dp[i][j - 1] + 1 insert word2[j - 1], dp[i - 1][j - 1] + 1 replace word1[i - 1] with word2[j - 1]
                    dp[i][j] = Math.min(dp[i - 1][j] + 1, dp[i][j - 1] + 1, dp[i - 1][j - 1] + 1);
                }
            }
        }
        return dp[m][n]
    };
\end{lstlisting}
