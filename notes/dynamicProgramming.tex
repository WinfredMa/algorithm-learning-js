\part{动态规划}

\section{爬楼梯}

\textbf{题目描述：}
假设你正在爬楼梯。需要 n 阶你才能到达楼顶。

每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？

\textbf{解法一：}

\begin{lstlisting}
const climbStairs2 = (n) => {
    if (n <= 2) {
        return n;
    }
    
    let dp = new Array(n + 1);
    dp[1] = 1;
    dp[2] = 2;
    
    for (let i = 3; i <= n; i++) {
        dp[i] = dp[i - 1] + dp[i - 2];
    }
    
    return dp[n];
};
\end{lstlisting}

\textbf{解法二：}

\begin{lstlisting}
const climbStairs = (n) => {
    let firstStage = 1, secondStage = 2, latestStage

    if (n < 3) {
        return n;
    }
    for (let i = 3; i <= n; i++) {
        latestStage = firstStage + secondStage;
        firstStage = secondStage;
        secondStage = latestStage;
    }
    return latestStage;
};
\end{lstlisting}

\section{杨辉三角}

\textbf{题目描述：}

给定一个非负整数 numRows，生成「杨辉三角」的前 numRows 行。

在「杨辉三角」中，每个数是它左上方和右上方的数的和。

\textbf{解法一：}

\begin{lstlisting}
const generate = (numRows) => {
    const result = [];

    for (let i = 0; i < numRows; i++) {
        const row = new Array(i + 1).fill(1);
        for (let j = 1; j < i; j++) {
            row[j] = result[i - 1][j - 1] + result[i - 1][j];
        }
        result.push(row);
    }
    return result;
}
\end{lstlisting}

\textbf{解法二：}

\begin{lstlisting}
const generate = (numRows) => {
    if (numRows === 0) {
        return [];
    }
    const triangle = [];
    
    for (let i = 0; i < numRows; i++) {
        const row = new Array(i + 1);
        row[0] = 1;
        row[i] = 1;
        
        for (let j = 1; j < i; j++) {
            row[j] = triangle[i - 1][j - 1] + triangle[i - 1][j];
        }
        
        triangle.push(row);
    }
    
    return triangle;
}
\end{lstlisting}

\section{打家劫舍}
\textbf{题目描述：}

你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。

给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。

\textbf{解法一：}

\begin{lstlisting}
const rob = (nums) => {
    const dp = new Array(nums.length).fill(0);
    dp[0] = nums[0];
    if (nums.length >= 2) {
        dp[1] = Math.max(nums[0], nums[1]);
    }

    for (let i = 2; i < nums.length; i++) {
        dp[i] = Math.max(dp[i-2] + nums[i], dp[i-1]);
    }

    return dp[nums.length -1];
};
\end{lstlisting}

\textbf{解法二：}

\begin{lstlisting}
const rob = (nums) => {
    let prev = 0;    // dp[i-2]
    let curr = 0;    // dp[i-1]
    
    for (let num of nums) {
        const temp = curr;
        curr = Math.max(curr, prev + num);
        prev = temp;
    }
    
    return curr;
};
\end{lstlisting}

