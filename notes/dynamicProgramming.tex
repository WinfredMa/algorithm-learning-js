\part{动态规划}

\section{爬楼梯}

\textbf{题目描述：}
假设你正在爬楼梯。需要 n 阶你才能到达楼顶。

每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？

\textbf{解法一：}

\begin{lstlisting}
const climbStairs2 = (n) => {
    if (n <= 2) {
        return n;
    }
    
    let dp = new Array(n + 1);
    dp[1] = 1;
    dp[2] = 2;
    
    for (let i = 3; i <= n; i++) {
        dp[i] = dp[i - 1] + dp[i - 2];
    }
    
    return dp[n];
};
\end{lstlisting}

\textbf{解法二：}

\begin{lstlisting}
const climbStairs = (n) => {
    let firstStage = 1, secondStage = 2, latestStage

    if (n < 3) {
        return n;
    }
    for (let i = 3; i <= n; i++) {
        latestStage = firstStage + secondStage;
        firstStage = secondStage;
        secondStage = latestStage;
    }
    return latestStage;
};
\end{lstlisting}

\section{杨辉三角}

\textbf{题目描述：}

给定一个非负整数 numRows，生成「杨辉三角」的前 numRows 行。

在「杨辉三角」中，每个数是它左上方和右上方的数的和。

\textbf{解法一：}

\begin{lstlisting}
const generate = (numRows) => {
    const result = [];

    for (let i = 0; i < numRows; i++) {
        const row = new Array(i + 1).fill(1);
        for (let j = 1; j < i; j++) {
            row[j] = result[i - 1][j - 1] + result[i - 1][j];
        }
        result.push(row);
    }
    return result;
}
\end{lstlisting}

\textbf{解法二：}

\begin{lstlisting}
const generate = (numRows) => {
    if (numRows === 0) {
        return [];
    }
    const triangle = [];
    
    for (let i = 0; i < numRows; i++) {
        const row = new Array(i + 1);
        row[0] = 1;
        row[i] = 1;
        
        for (let j = 1; j < i; j++) {
            row[j] = triangle[i - 1][j - 1] + triangle[i - 1][j];
        }
        
        triangle.push(row);
    }
    
    return triangle;
}
\end{lstlisting}

\section{打家劫舍}
\textbf{题目描述：}

你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。

给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。

\textbf{解法一：}

\begin{lstlisting}
const rob = (nums) => {
    const dp = new Array(nums.length).fill(0);
    dp[0] = nums[0];
    if (nums.length >= 2) {
        dp[1] = Math.max(nums[0], nums[1]);
    }

    for (let i = 2; i < nums.length; i++) {
        dp[i] = Math.max(dp[i-2] + nums[i], dp[i-1]);
    }

    return dp[nums.length -1];
};
\end{lstlisting}

\textbf{解法二：}

\begin{lstlisting}
const rob = (nums) => {
    let prev = 0;    // dp[i-2]
    let curr = 0;    // dp[i-1]
    
    for (let num of nums) {
        const temp = curr;
        curr = Math.max(curr, prev + num);
        prev = temp;
    }
    
    return curr;
};
\end{lstlisting}

\section{完全平方数}

\textbf{题目描述：}

给你一个整数 n ，返回 和为 n 的完全平方数的最少数量 。

完全平方数 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，1、4、9 和 16 都是完全平方数，而 3 和 11 不是。

\textbf{解法一：}

\begin{lstlisting}
    const numSquares = (n) => {
        const dp = new Array(n + 1).fill(0);
         
        for (let i = 1; i <= n; i++) {
            let min = Infinity;
            for (let j = 1; j*j <=i; j++) {
                min = Math.min(min, dp[i - j*j]);
            }
    
            dp[i] = min + 1;
        }
        
        return dp[n];
    };
\end{lstlisting}

\textbf{解法二：}

\begin{lstlisting}
const numSquares = (n) => {
    const dp = new Array(n + 1).fill(Infinity);
    dp[0] = 0;
    
    for (let i = 1; i <= n; i++) {
        for (let j = 1; j*j <= i; j++) {
            dp[i] = Math.min(dp[i], dp[i - j*j] + 1);
        }
    }
    
    return dp[n];
};
\end{lstlisting}


\section{零钱兑换}

\textbf{题目描述：}

给你一个整数数组 coins ，表示不同面额的硬币；以及一个整数 amount ，表示总金额。

计算并返回可以凑成总金额所需的 最少的硬币个数 。如果没有任何一种硬币组合能组成总金额，返回 -1 。

你可以认为每种硬币的数量是无限的。

\textbf{解法一：}

\begin{lstlisting}
    const coinChange = (coins, amount) => {
        const dp = new Array(amount + 1).fill(amount + 1);
        dp[0] = 0;
        
        for (let i = 1; i <= amount; i++) {
            for (const coin of coins) {
                if (coin <= i) {
                    dp[i] = Math.min(dp[i], dp[i - coin] + 1);
                }
            }
        }
        
        return dp[amount] > amount ? -1 : dp[amount];   
    };
\end{lstlisting}

\textbf{解法二：}

\begin{lstlisting}
    const coinChange2 = (coins, amount) => {
        if (!amount) {
            return 0;
        }
        let dp = new Array(amount + 1).fill(Infinity);
        dp[0] = 0;
        for (let i = 0; i < coins.length; i++) {
            for (let j = coins[i]; j <= amount; j++) {
                dp[j] = Math.min(dp[j - coins[i]] + 1, dp[j]);
            }
        }
        return dp[amount] === Infinity ? -1 : dp[amount];
    };
\end{lstlisting}