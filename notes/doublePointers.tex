\part{双指针}

\section{移动零}

\textbf{题目描述：}
给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。

请注意 ，必须在不复制数组的情况下原地对数组进行操作。

\textbf{解法一：}

\begin{lstlisting}
const moveZeroes = (nums) => {
    let zeroNum = 0;

    for (let i = 0; i < nums.length - zeroNum; ) {
        if (nums[i] === 0) {
            nums.splice(i, 1);
            nums.push(0);
            zeroNum ++;
        } else {
            i++;
        }
    }
};
\end{lstlisting}

\textbf{解法二：}

\begin{lstlisting}
const moveZeroes2 = function(nums) {
    let n = nums.length, left = 0, right = 0;
    
    while (right < n) {
        if (nums[right] !== 0) {
            [nums[left], nums[right]] = [nums[right], nums[left]];
            left++;
        }
        right++;
    }
};
\end{lstlisting}

\section{盛最多水的容器}
\textbf{题目描述：}

给定一个长度为 n 的整数数组 height 。有 n 条垂线，第 i 条线的两个端点是 (i, 0) 和 (i, height[i]) 。

找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。

返回容器可以储存的最大水量

\textbf{解法一：}

\begin{lstlisting}
const maxArea = (height) => {
    let max = 0;

    let left = 0; 
    let right = height.length - 1;

    while( left < right) {
        const area = Math.min(height[left], height[right]) * (right - left);
        max = Math.max(max, area);
        if (height[left] <= height[right]) {
            left++
        } else if (height[left] > height[right]) {
            right --;
        }
    }
    return max
};
\end{lstlisting}

\section{三数之和}
\textbf{题目描述：}

给你一个整数数组 nums ，判断是否存在三元组 [nums[i], nums[j], nums[k]] 满足 i != j、i != k 且 j != k ，同时还满足 nums[i] + nums[j] + nums[k] == 0 。请你返回所有和为 0 且不重复的三元组。

注意：答案中不可以包含重复的三元组。

\textbf{解法一：}

\begin{lstlisting}
const threeSum = (nums) => {
    const result = [];
    nums.sort((a, b) => a - b);
    for(let i = 0; i < nums.length - 2; i++) {
        if (i > 0 && nums[i] === nums[i - 1]) {
            continue;  
        }
        let k = nums.length - 1
        for (let j = i + 1; j < nums.length - 1; j++) {
            if (j > i + 1 && nums[j] === nums[j - 1]) {
                continue;
            }
            
            while (j < k && nums[i] + nums[j] + nums[k] > 0) {
                k --
            }
            if (j === k) {
                break;
            }
            if (nums[i] + nums[j] + nums[k] === 0) {
                result.push([nums[i], nums[j], nums[k]]);
            }
        }
    }
    return result
};
\end{lstlisting}

\section{接雨水}

\textbf{题目描述：}

给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水

\textbf{解法一：}

\begin{lstlisting}
const trap = (height) => {
    let left = 0;
    let right = height.length - 1;
    let maxLeft = 0;
    let maxRight = 0;
    let result = 0;

    while (left < right) {
        if (height[left] < height[right]) {
            if (height[left] >= maxLeft) {
                maxLeft = height[left];
            } else {
                result += maxLeft - height[left];
            }
            left++;
        } else {
            if (height[right] >= maxRight) {
                maxRight = height[right];
            } else {
                result += maxRight - height[right];
            }
            right--;
        }
    }

    return result;
};
\end{lstlisting}

\section{寻找重复数}

\textbf{题目描述：}

给定一个包含 n + 1 个整数的数组 nums ，其数字都在 [1, n] 范围内（包括 1 和 n），可知至少存在一个重复的整数。

假设 nums 只有 一个重复的整数 ，返回 这个重复的数 。

你设计的解决方案必须 不修改 数组 nums 且只用常量级 O(1) 的额外空间。

\textbf{解法一：}

\begin{lstlisting}
    const findDuplicate = (nums) => {
        let slow = nums[0];
        let fast = nums[0];
        do {
            slow = nums[slow];
            fast = nums[nums[fast]];
        } while( slow !== fast)
    
        slow = nums[0];
    
        while(slow !== fast) {
            slow = nums[slow];
            fast = nums[fast];
        }
    
        return slow
    };
\end{lstlisting}

\textbf{解法二：}

\begin{lstlisting}
    const findDuplicate2 = (nums) => {
        let left = 1;
        let right = nums.length - 1;
        
        while (left < right) {
            const mid = Math.floor((left + right) / 2);
            let count = 0;
            
            for (let num of nums) {
                if (num <= mid) {
                    count++;
                }
            }
            
            if (count > mid) {
                right = mid;
            } else {
                left = mid + 1;
            }
        }
        
        return left;
    }
\end{lstlisting}