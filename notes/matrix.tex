\part{矩阵}

\section{矩阵置零}

\textbf{题目描述：}

给定一个 m x n 的矩阵，如果一个元素为 0 ，则将其所在行和列的所有元素都设为 0 。请使用 原地 算法。

\textbf{解法一：}

\begin{lstlisting}
    const setZeroes = (matrix) => {
        let m = matrix.length;
        let n = matrix[0].length;
        const rows = new Array(m).fill(false);
        const cols = new Array(n).fill(false);
        for (let i = 0; i < m; i++) {
            for (let j = 0; j < n; j++) {
                if (matrix[i][j] == 0) {
                    rows[i] = cols[j] = true;
                }
            }
        }
        
        for (let i = 0; i < m; i++) {
            for (let j = 0; j < n; j++) {
                if (rows[i] || cols[j]) {
                    matrix[i][j] = 0;
                }
            }
        }
    };
\end{lstlisting}

\textbf{解法二：}

\begin{lstlisting}
    const setZeroes2 = (matrix) => {
        const m = matrix.length;
        const n = matrix[0].length;
        const ignoreRows = [];
        const ignoreCols = []
        for (let i = 0; i< m; i++) {
            for (let j = 0; j < n; j++) {
                if (matrix[i][j] === 0) {
                    ignoreRows.push(i);
                    ignoreCols.push(j);
                }
            }
        }
        for (let l = 0; l < ignoreRows.length; l++) {
            for (let k = 0; k < n; k++) {
                matrix[ignoreRows[l]][k] = 0;
            }
        }

        for (let l = 0; l < ignoreCols.length; l++) {
            for (let k = 0; k < m; k++) {
                matrix[k][ignoreCols[l]] = 0;
            }
        }
    };
\end{lstlisting}

\section{螺旋矩阵}

\textbf{题目描述：}

给你一个 m 行 n 列的矩阵 matrix ，请按照 顺时针螺旋顺序 ，返回矩阵中的所有元素。

\textbf{解法一：}

\begin{lstlisting}
    const spiralOrder = (matrix) => {
        let result = [];
        let flag = 0;

        while (matrix.length) {
            switch(flag % 4) {
                case 0: result.push(...matrix.shift());
                break;
                case 1: for( let i = 0; i < matrix.length; i++) {
                    result.push(...matrix[i].splice(matrix[i].length - 1, 1));
                }
                break;
                case 2: result.push(...matrix.pop().reverse());
                break;
                case 3: for (let j = matrix.length - 1; j >=0; j--) {
                    result.push(...matrix[j].splice(0, 1));
                }
                break;

            }
            flag++;
        }
        
        return result;
    };
\end{lstlisting}

\textbf{解法二：}

\begin{lstlisting}
    const spiralOrder2 = (matrix) => {
        if (!matrix || matrix.length === 0 || matrix[0].length === 0) {
            return [];
        }
        
        const m = matrix.length;
        const n = matrix[0].length;
        let top = 0, bottom = m - 1, left = 0, right = n - 1;
        const result = [];
        
        while (top <= bottom && left <= right) {
            for (let col = left; col <= right; col++) {
                result.push(matrix[top][col]);
            }
            top++;
            
            for (let row = top; row <= bottom; row++) {
                result.push(matrix[row][right]);
            }
            right--;
            
            if (top <= bottom) {
                for (let col = right; col >= left; col--) {
                    result.push(matrix[bottom][col]);
                }
                bottom--;
            }
            
            if (left <= right) {
                for (let row = bottom; row >= top; row--) {
                    result.push(matrix[row][left]);
                }
                left++;
            }
        }
        
        return result;
    }
\end{lstlisting}

\section{旋转图像}
\textbf{题目描述：}

给定一个 n × n 的二维矩阵 matrix 表示一个图像。请你将图像顺时针旋转 90 度。

你必须在 原地 旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要 使用另一个矩阵来旋转图像。

\textbf{解法一：}

\begin{lstlisting}
    const rotate = (matrix) => {
        const n = matrix.length;
        for (let i = 0; i < Math.floor(n / 2); i++) {
            for (let j = 0; j < n; j++) {
                [matrix[i][j], matrix[n - i - 1][j]] = [matrix[n - i - 1][j], matrix[i][j]];
            }
        }

        for (let i = 0; i < n; i++) {
            for (let j = 0; j < i; j++) {
                [matrix[i][j], matrix[j][i]] = [matrix[j][i], matrix[i][j]]
            }
        }
    };
\end{lstlisting}

\textbf{解法二：}

\begin{lstlisting}
    const rotate2 = (matrix) => {
        let temp;
        const n = matrix.length;
        for (let i = 0; i < Math.floor(n/2); i++) {
            for (let j = 0; j < Math.floor((n + 1)/2); j++) {
                temp = matrix[i][j];
                matrix[i][j] = matrix[n - j - 1][i];
                matrix[n - j - 1][i] = matrix[n - i -1][n - j - 1];
                matrix[n - i - 1][n - j - 1] = matrix[j][n - i - 1];
                matrix[j][n - i - 1] = temp;
            }
        }
    };
\end{lstlisting}

\section{搜索二维矩阵 II}
\textbf{题目描述：}

编写一个高效的算法来搜索 m x n 矩阵 matrix 中的一个目标值 target 。该矩阵具有以下特性：

每行的元素从左到右升序排列。
每列的元素从上到下升序排列。

\textbf{解法一：}

\begin{lstlisting}
    const searchMatrix = (matrix, target) => {
        let m = matrix.length;
        let n = matrix[0].length;

        for (let i = 0; i < m; i++) {
            if(target> matrix[i][n -1]) {
                continue;
            } else {
                let left = 0; right = n -1;
                while (left <= right) {
                    let mid = Math.floor((left + right)/2);
                    if (target == matrix[i][mid]) {
                        return true;
                    }
                    if (target < matrix[i][mid]) {
                        right = mid - 1;
                    } else {
                        left = mid + 1;
                    }
                }
            }
        }

        return false;
    };
\end{lstlisting}

\textbf{解法二：}

\begin{lstlisting}
    const searchMatrix2 = (matrix, target) => {
        const m = matrix.length, n = matrix[0].length;
        let x = 0, y = n - 1;
        while (x < m && y >= 0) {
            if (matrix[x][y] === target) {
                return true;
            }
            if (matrix[x][y] > target) {
                --y;
            } else {
                ++x;
            }
        }
        
        return false;
    };
\end{lstlisting}

